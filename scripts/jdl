#!/bin/bash

# Johnny Decimal Linter (jdl)
# Checks if directories follow Johnny Decimal naming conventions
# Format: NN-name (where NN is 10-99 and name is lowercase with hyphens)

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
VERBOSE=false
RECURSIVE=false
FIX_MODE=false
ERRORS_ONLY=false
CHECK_FILES=false
TARGET_PATH="."

# Help function
show_help() {
    cat <<EOF
Johnny Decimal Linter (jdl)

Usage: $0 [OPTIONS] [PATH]

Checks if directories and files follow Johnny Decimal naming conventions.

DIRECTORY NAMING:
- Format: NN-name (where NN is 10-99) or NN-NN - Name (range format)
- Subdirectories: NN - Name, NN.NN - Name, or NN.NNNNN - Name (decimal format)
- Exception: "Inbox" folder is allowed at root level

FILE NAMING (with --files):
- Format: {Category} - {Subcategory} - {Date} - {Description}.{ext}
- Category/Subcategory derived from parent folder names
- Date is optional, format: YYYY-MM-DD
- Example: Bigfoot - Meeting - 2024-05-14 - Retour Septeo.xlsx

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Verbose output (shows all directories/files)
    -e, --errors-only   Show only errors (invalid items)
    -r, --recursive     Check subdirectories recursively
    -f, --fix           Attempt to fix naming issues (interactive)
    --files             Also check file naming conventions
    PATH                Target path to check (default: current directory)

EXAMPLES:
    $0                    # Check current directory (dirs only)
    $0 -r /path/to/check  # Check recursively (dirs only)
    $0 --files -r .       # Check dirs and files recursively
    $0 -e --files -r .    # Show only errors for dirs and files

EXIT CODES:
    0 - All paths follow Johnny Decimal conventions
    1 - Some paths have issues
    2 - Error occurred

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        show_help
        exit 0
        ;;
    -v | --verbose)
        VERBOSE=true
        shift
        ;;
    -e | --errors-only)
        ERRORS_ONLY=true
        shift
        ;;
    -r | --recursive)
        RECURSIVE=true
        shift
        ;;
    -f | --fix)
        FIX_MODE=true
        shift
        ;;
    --files)
        CHECK_FILES=true
        shift
        ;;
    -*)
        echo -e "${RED}Error: Unknown option $1${NC}" >&2
        show_help
        exit 2
        ;;
    *)
        TARGET_PATH="$1"
        shift
        ;;
    esac
done

# Validate target path exists
if [[ ! -d "$TARGET_PATH" ]]; then
    echo -e "${RED}Error: Target path '$TARGET_PATH' does not exist or is not a directory${NC}" >&2
    exit 2
fi

# Johnny Decimal validation functions
is_johnny_decimal() {
    local dirname="$1"

    # Check if it matches the pattern: NN-name (strict format)
    if [[ "$dirname" =~ ^([1-9][0-9])-([a-z0-9-]+)$ ]]; then
        local number="${BASH_REMATCH[1]}"
        local name="${BASH_REMATCH[2]}"

        # Check if number is in valid range (10-99)
        if [[ "$number" -ge 10 && "$number" -le 99 ]]; then
            # Check if name doesn't start or end with hyphen
            if [[ "$name" != *- && "$name" != -* ]]; then
                return 0
            fi
        fi
    fi

    # Check if it matches the pattern: NN-NN - Name (range format)
    if [[ "$dirname" =~ ^([1-9][0-9])-([1-9][0-9])\ -(.+)$ ]]; then
        local start_number="${BASH_REMATCH[1]}"
        local end_number="${BASH_REMATCH[2]}"
        local name="${BASH_REMATCH[3]}"

        # Check if numbers are in valid range (10-99) and start <= end
        if [[ "$start_number" -ge 10 && "$start_number" -le 99 &&
            "$end_number" -ge 10 && "$end_number" -le 99 &&
            "$start_number" -le "$end_number" ]]; then
            # Trim leading/trailing spaces from name
            name=$(echo "$name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -n "$name" ]]; then
                return 0
            fi
        fi
    fi

    # Check if it matches the pattern: NN.NNNNN - Name (decimal format)
    if [[ "$dirname" =~ ^([1-9][0-9])\.([0-9]{5})\ -(.+)$ ]]; then
        local category="${BASH_REMATCH[1]}"
        local sub_number="${BASH_REMATCH[2]}"
        local name="${BASH_REMATCH[3]}"

        # Check if category is in valid range (10-99)
        if [[ "$category" -ge 10 && "$category" -le 99 ]]; then
            # Trim leading/trailing spaces from name
            name=$(echo "$name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -n "$name" ]]; then
                return 0
            fi
        fi
    fi

    # Check if it matches the pattern: NN.NN - Name (decimal format)
    if [[ "$dirname" =~ ^([1-9][0-9])\.([0-9]{2})\ -(.+)$ ]]; then
        local category="${BASH_REMATCH[1]}"
        local sub_number="${BASH_REMATCH[2]}"
        local name="${BASH_REMATCH[3]}"

        # Check if category is in valid range (10-99)
        if [[ "$category" -ge 10 && "$category" -le 99 ]]; then
            # Trim leading/trailing spaces from name
            name=$(echo "$name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -n "$name" ]]; then
                return 0
            fi
        fi
    fi

    # Check if it matches the pattern: NN - Name (simple format)
    if [[ "$dirname" =~ ^([1-9][0-9])\ -(.+)$ ]]; then
        local number="${BASH_REMATCH[1]}"
        local name="${BASH_REMATCH[2]}"

        # Check if number is in valid range (10-99)
        if [[ "$number" -ge 10 && "$number" -le 99 ]]; then
            # Trim leading/trailing spaces from name
            name=$(echo "$name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -n "$name" ]]; then
                return 0
            fi
        fi
    fi

    return 1
}

# Extract the descriptive name from a JD folder name
# "21 - Bigfoot" -> "Bigfoot"
# "21.03 - Meeting" -> "Meeting"
# "10.25001 - Import Quadral" -> "Import Quadral"
extract_jd_name() {
    local dirname="$1"

    # Pattern: NN - Name, NN.NN - Name, NN.NNNNN - Name, NN-NN - Name
    if [[ "$dirname" =~ ^[0-9]+(\.[0-9]+)?\ -\ (.+)$ ]]; then
        echo "${BASH_REMATCH[2]}"
        return 0
    fi

    # Pattern: NN-NN - Name (range format)
    if [[ "$dirname" =~ ^[0-9]+-[0-9]+\ -\ (.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # Not a JD folder, return as-is
    echo "$dirname"
}

# Build the expected file prefix from the folder path
# /path/to/21 - Bigfoot/21.03 - Meeting/ -> "Bigfoot - Meeting"
build_file_prefix() {
    local file_path="$1"
    local parent_dir=$(dirname "$file_path")
    local grandparent_dir=$(dirname "$parent_dir")

    local parent_name=$(basename "$parent_dir")
    local grandparent_name=$(basename "$grandparent_dir")

    # Extract JD names
    local subcategory=$(extract_jd_name "$parent_name")
    local category=$(extract_jd_name "$grandparent_name")

    # Skip if we're at root level (grandparent is the JD root like "20-29 - Areas")
    if [[ "$grandparent_name" =~ ^[0-9]+-[0-9]+\ - ]]; then
        # Only one level deep, use just the category
        echo "$subcategory"
    else
        echo "$category - $subcategory"
    fi
}

# Check if a filename follows the JD file naming convention
# Format: {Prefix} - {Date}? - {Description}.{ext}
is_valid_jd_filename() {
    local filename="$1"
    local expected_prefix="$2"

    # Remove extension for checking
    local basename="${filename%.*}"

    # Check if it starts with the expected prefix
    if [[ ! "$basename" == "$expected_prefix"* ]]; then
        return 1
    fi

    # Get the part after the prefix
    local remainder="${basename#$expected_prefix}"

    # Should start with " - " if there's more content
    if [[ -n "$remainder" && ! "$remainder" =~ ^\ -\  ]]; then
        return 1
    fi

    # Remove leading " - "
    remainder="${remainder#\ -\ }"

    # Check if next part is a date (YYYY-MM-DD) or description
    if [[ -n "$remainder" ]]; then
        # Optional date pattern
        if [[ "$remainder" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2})\ -\ (.+)$ ]]; then
            # Has date and description - valid
            return 0
        elif [[ "$remainder" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2})$ ]]; then
            # Just a date - valid but unusual
            return 0
        elif [[ "$remainder" =~ ^[^-] ]]; then
            # Description without date - valid
            return 0
        fi
    fi

    # Just the prefix is also valid (though unusual)
    return 0
}

# Check a single file
check_file() {
    local file_path="$1"
    local filename=$(basename "$file_path")
    local parent_dir=$(dirname "$file_path")

    # Skip hidden files
    if [[ "$filename" =~ ^\. ]]; then
        return 0
    fi

    # Skip if parent is Inbox (files there are not yet organized)
    if [[ "$(basename "$parent_dir")" == "Inbox" ]]; then
        return 0
    fi

    # Skip if parent is a range folder (like "10-19 - Projets")
    if [[ "$(basename "$parent_dir")" =~ ^[0-9]+-[0-9]+\ - ]]; then
        return 0
    fi

    # Build expected prefix
    local expected_prefix=$(build_file_prefix "$file_path")

    if is_valid_jd_filename "$filename" "$expected_prefix"; then
        if [[ "$VERBOSE" == "true" && "$ERRORS_ONLY" != "true" ]]; then
            echo -e "${GREEN}✓${NC} $file_path"
        fi
        return 0
    else
        echo -e "${RED}✗${NC} $file_path"
        echo -e "  ${YELLOW}Expected prefix: ${expected_prefix} - ...${NC}"
        return 1
    fi
}

# Get suggested name for a directory
suggest_name() {
    local dirname="$1"
    local basename=$(basename "$dirname")

    # If it's already a valid Johnny Decimal name, return as is
    if is_johnny_decimal "$basename"; then
        echo "$basename"
        return
    fi

    # Extract the name part (remove any existing numbers)
    local clean_name=$(echo "$basename" | sed 's/^[0-9]*[-_]*//' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')

    # Generate a placeholder number (you might want to make this smarter)
    local suggested_number="50"

    echo "${suggested_number}-${clean_name}"
}

# Check a single directory
check_directory() {
    local dir_path="$1"
    local dir_name=$(basename "$dir_path")
    local parent_path=$(dirname "$dir_path")

    # Skip hidden directories and common system directories
    if [[ "$dir_name" =~ ^\. ]] || [[ "$dir_name" =~ ^(node_modules|\.git|\.svn|\.hg)$ ]]; then
        return 0
    fi

    # Allow "Inbox" folder at root level
    if [[ "$dir_name" == "Inbox" && "$parent_path" == "$TARGET_PATH" ]]; then
        if [[ "$VERBOSE" == "true" ]]; then
            echo -e "${GREEN}✓${NC} $dir_path (Inbox at root)"
        fi
        return 0
    fi

    # Handle trailing slash in TARGET_PATH for Inbox check
    local normalized_target=$(echo "$TARGET_PATH" | sed 's|/$||')
    if [[ "$dir_name" == "Inbox" && "$parent_path" == "$normalized_target" ]]; then
        if [[ "$VERBOSE" == "true" ]]; then
            echo -e "${GREEN}✓${NC} $dir_path (Inbox at root)"
        fi
        return 0
    fi

    if is_johnny_decimal "$dir_name"; then
        if [[ "$VERBOSE" == "true" && "$ERRORS_ONLY" != "true" ]]; then
            echo -e "${GREEN}✓${NC} $dir_path"
        fi
        return 0
    else
        echo -e "${RED}✗${NC} $dir_path"
        echo -e "  ${YELLOW}Expected format: NN-name (where NN is 10-99)${NC}"

        if [[ "$FIX_MODE" == "true" ]]; then
            local suggested_name=$(suggest_name "$dir_path")
            echo -e "  ${BLUE}Suggested name: $suggested_name${NC}"

            read -p "  Rename to '$suggested_name'? (y/n): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                local new_path="$parent_path/$suggested_name"
                if [[ -e "$new_path" ]]; then
                    echo -e "  ${RED}Error: '$new_path' already exists${NC}"
                else
                    mv "$dir_path" "$new_path"
                    echo -e "  ${GREEN}Renamed to: $new_path${NC}"
                fi
            fi
        fi
        return 1
    fi
}

# Main function to check directories
check_paths() {
    local target="$1"
    local has_errors=false
    local dir_error_count=0
    local file_error_count=0

    if [[ "$VERBOSE" == "true" || "$ERRORS_ONLY" == "true" ]]; then
        echo -e "${BLUE}Checking Johnny Decimal compliance for: $target${NC}"
        if [[ "$CHECK_FILES" == "true" ]]; then
            echo -e "${BLUE}(including file naming)${NC}"
        fi
        echo
    fi

    # Find directories to check
    local find_cmd="find \"$target\" -maxdepth 1 -type d"
    if [[ "$RECURSIVE" == "true" ]]; then
        find_cmd="find \"$target\" -type d"
    fi

    # Skip the target directory itself if it's not the current directory
    if [[ "$target" != "." ]]; then
        find_cmd="$find_cmd -not -path \"$target\""
    fi

    # Process each directory
    while IFS= read -r -d '' dir; do
        if ! check_directory "$dir"; then
            has_errors=true
            ((dir_error_count++))
        fi
    done < <(eval "$find_cmd -print0")

    # Check files if requested
    if [[ "$CHECK_FILES" == "true" ]]; then
        local find_files_cmd="find \"$target\" -maxdepth 2 -type f"
        if [[ "$RECURSIVE" == "true" ]]; then
            find_files_cmd="find \"$target\" -type f"
        fi

        while IFS= read -r -d '' file; do
            if ! check_file "$file"; then
                has_errors=true
                ((file_error_count++))
            fi
        done < <(eval "$find_files_cmd -print0")
    fi

    if [[ "$has_errors" == "true" ]]; then
        echo
        if [[ "$dir_error_count" -gt 0 ]]; then
            if [[ "$dir_error_count" -eq 1 ]]; then
                echo -e "${RED}1 directory does not follow Johnny Decimal conventions${NC}"
            else
                echo -e "${RED}$dir_error_count directories do not follow Johnny Decimal conventions${NC}"
            fi
        fi
        if [[ "$file_error_count" -gt 0 ]]; then
            if [[ "$file_error_count" -eq 1 ]]; then
                echo -e "${RED}1 file does not follow naming conventions${NC}"
            else
                echo -e "${RED}$file_error_count files do not follow naming conventions${NC}"
            fi
        fi
        return 1
    else
        if [[ "$VERBOSE" == "true" && "$ERRORS_ONLY" != "true" ]]; then
            echo
            echo -e "${GREEN}All items follow Johnny Decimal conventions!${NC}"
        fi
        return 0
    fi
}

# Summary function
show_summary() {
    echo
    echo -e "${BLUE}Johnny Decimal Rules:${NC}"
    echo
    echo -e "  ${YELLOW}Directories:${NC}"
    echo "  • Format: NN-name, NN - Name, NN-NN - Name, or NN.NN - Name"
    echo "  • NN should be a number between 10-99"
    echo "  • Examples: 10-19 - Projects, 21 - Bigfoot, 21.03 - Meeting"
    echo "  • Exception: 'Inbox' folder is allowed at root level"
    if [[ "$CHECK_FILES" == "true" ]]; then
        echo
        echo -e "  ${YELLOW}Files:${NC}"
        echo "  • Format: {Category} - {Subcategory} - {Date} - {Description}.{ext}"
        echo "  • Prefix derived from parent folder names"
        echo "  • Date is optional, format: YYYY-MM-DD"
        echo "  • Example: Bigfoot - Meeting - 2024-05-14 - Retour Septeo.xlsx"
    fi
    echo
}

# Main execution
main() {
    show_summary

    if check_paths "$TARGET_PATH"; then
        exit 0
    else
        exit 1
    fi
}

# Run main function
main "$@"
